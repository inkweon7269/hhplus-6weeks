import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import * as request from 'supertest';
import { getTestDatasource } from '../setup';
import { AppModule } from '../../../src/app.module';
import { IProductRepository, PRODUCT_REPOSITORY } from '../../../src/product/domain/product.repository.interface';
import {
  IProductOptionRepository,
  PRODUCT_OPTION_REPOSITORY,
} from '../../../src/product/domain/product-option.repository.interface';
import { IBalanceRepository, BALANCE_REPOSITORY } from '../../../src/balance/domain/balance.repository.interface';
import { IUserRepository, USER_REPOSITORY } from '../../../src/user/domain/user.repository.interface';
import { ICouponRepository, COUPON_REPOSITORY } from '../../../src/coupon/domain/coupon.repository.interface';
import {
  IUserCouponRepository,
  USER_COUPON_REPOSITORY,
} from '../../../src/coupon/domain/user-coupon.repository.interface';
import { CouponStatus } from '../../../src/coupon/enum/coupon-status.enum';

describe('Concurrency Issues Integration Test', () => {
  let app: INestApplication;
  let productRepository: IProductRepository;
  let productOptionRepository: IProductOptionRepository;
  let balanceRepository: IBalanceRepository;
  let userRepository: IUserRepository;
  let couponRepository: ICouponRepository;
  let userCouponRepository: IUserCouponRepository;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();

    // Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨ Ï£ºÏûÖ
    productRepository = moduleFixture.get<IProductRepository>(PRODUCT_REPOSITORY);
    productOptionRepository = moduleFixture.get<IProductOptionRepository>(PRODUCT_OPTION_REPOSITORY);
    balanceRepository = moduleFixture.get<IBalanceRepository>(BALANCE_REPOSITORY);
    userRepository = moduleFixture.get<IUserRepository>(USER_REPOSITORY);
    couponRepository = moduleFixture.get<ICouponRepository>(COUPON_REPOSITORY);
    userCouponRepository = moduleFixture.get<IUserCouponRepository>(USER_COUPON_REPOSITORY);

    // ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
    await userRepository.save({
      id: 1,
      name: 'Test User',
    });

    // ÏÉÅÌíà ÏÉùÏÑ±
    await productRepository.saveProduct({
      id: 1,
      name: 'Test Product',
    });

    // ÏÉÅÌíà ÏòµÏÖò ÏÉùÏÑ± (Ïû¨Í≥† 10Í∞ú)
    await productOptionRepository.saveProductOption({
      id: 1,
      productId: 1,
      name: 'Test Option',
      price: 10000,
      stock: 10,
    });

    // Í∏∞Î≥∏ ÏûîÏï°ÏùÄ beforeEachÏóêÏÑú ÏÑ§Ï†ïÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Ï†úÍ±∞

    // Ïø†Ìè∞ ÏÉùÏÑ±
    await couponRepository.saveCoupon({
      id: 1,
      couponCode: 'TEST001',
      name: 'Test Coupon',
      discountAmount: 1000,
      remainingStock: 5,
      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30Ïùº ÌõÑ
      status: CouponStatus.AVAILABLE,
    });
  });

  afterAll(async () => {
    if (app) {
      await app.close();
    }
  });

  beforeEach(async () => {
    // Í∞Å ÌÖåÏä§Ìä∏ Ï†ÑÏóê Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
    const datasource = getTestDatasource();
    await datasource.query('TRUNCATE TABLE user_coupons RESTART IDENTITY CASCADE');
    await datasource.query('TRUNCATE TABLE order_coupons RESTART IDENTITY CASCADE');
    await datasource.query('TRUNCATE TABLE order_product_options RESTART IDENTITY CASCADE');
    await datasource.query('TRUNCATE TABLE order_products RESTART IDENTITY CASCADE');
    await datasource.query('TRUNCATE TABLE orders RESTART IDENTITY CASCADE');

    // Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Ïû¨ÏÑ§Ï†ï
    await productOptionRepository.saveProductOption({
      id: 1,
      productId: 1,
      name: 'Test Option',
      price: 10000,
      stock: 10,
    });

    const existingBalance = await balanceRepository.findByUserId(1);
    if (existingBalance) {
      existingBalance.amount = 100000;
      await balanceRepository.save(existingBalance);
    } else {
      await balanceRepository.save({
        userId: 1,
        amount: 100000,
      });
    }

    await couponRepository.saveCoupon({
      id: 1,
      couponCode: 'TEST001',
      name: 'Test Coupon',
      discountAmount: 1000,
      remainingStock: 5,
      expiryDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30Ïùº ÌõÑ
      status: CouponStatus.AVAILABLE,
    });
  });

  describe('üì¶ Ïû¨Í≥† Í¥ÄÎ¶¨ Race Condition', () => {
    it('ÎèôÏãú Ï£ºÎ¨∏ÏúºÎ°ú Ïù∏Ìïú Ïû¨Í≥† Ïò§Î≤ÑÏÖÄÎßÅ Î¨∏Ï†ú', async () => {
      const concurrentOrders = 15; // Ïû¨Í≥† 10Í∞úÎ≥¥Îã§ ÎßéÏùÄ Ï£ºÎ¨∏
      const promises = [];

      for (let i = 0; i < concurrentOrders; i++) {
        const promise = request(app.getHttpServer())
          .post('/orders')
          .set('id', '1')
          .send({
            productOptionId: 1,
            quantity: 1,
          })
          .then((response) => response.body)
          .catch((error) => error.response?.body);
        promises.push(promise);
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.orderId);
      const failed = results.filter((result) => !result?.orderId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Ï£ºÎ¨∏: ${successful.length}Í∞ú`);
      console.log(`‚ùå Ïã§Ìå®Ìïú Ï£ºÎ¨∏: ${failed.length}Í∞ú`);

      // Ïû¨Í≥† ÌôïÏù∏
      const finalStock = await productOptionRepository.findById(1);
      console.log(`üì¶ ÏµúÏ¢Ö Ïû¨Í≥†: ${finalStock.stock}Í∞ú`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ Ïû¨Í≥†Í∞Ä ÏùåÏàòÍ∞Ä Îê† Ïàò ÏûàÏùå
      expect(finalStock.stock).toBeLessThanOrEqual(10);
      expect(successful.length + failed.length).toBe(concurrentOrders);
    });

    it('Ïû¨Í≥† ÌôïÏù∏Í≥º Ï£ºÎ¨∏ ÏÇ¨Ïù¥Ïùò ÏãúÍ∞ÑÏ∞® Í≥µÍ≤©', async () => {
      const checkAndOrder = async () => {
        const currentStock = await productOptionRepository.findById(1);
        if (currentStock.stock > 0) {
          // Ïû¨Í≥† ÌôïÏù∏ ÌõÑ ÏßÄÏó∞ÏùÑ ÎëêÍ≥† Ï£ºÎ¨∏ (race condition Ïú†Î∞ú)
          await new Promise((resolve) => setTimeout(resolve, Math.random() * 100));
          return request(app.getHttpServer())
            .post('/orders')
            .set('id', '1')
            .send({
              productOptionId: 1,
              quantity: 1,
            })
            .then((response) => response.body)
            .catch((error) => error.response?.body);
        }
        return null;
      };

      const concurrentAttempts = 20;
      const promises = [];

      for (let i = 0; i < concurrentAttempts; i++) {
        promises.push(checkAndOrder());
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.orderId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Ï£ºÎ¨∏: ${successful.length}Í∞ú`);

      // Ïû¨Í≥† ÌôïÏù∏
      const finalStock = await productOptionRepository.findById(1);
      console.log(`üì¶ ÏµúÏ¢Ö Ïû¨Í≥†: ${finalStock.stock}Í∞ú`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ Ïû¨Í≥†Í∞Ä ÏùåÏàòÍ∞Ä Îê† Ïàò ÏûàÏùå
      expect(finalStock.stock).toBeLessThanOrEqual(10);
    });
  });

  describe('üí∞ ÏûîÏï° Í¥ÄÎ¶¨ Race Condition - ÏùåÏàò ÏûîÏï° Î¨∏Ï†ú', () => {
    it('10,000Ïõê ÏûîÏï°Ïóê 8,000ÏõêÏî© 2Î≤à ÎèôÏãú Í≤∞Ï†úÏãúÎèÑ ‚Üí ÏùåÏàò ÏûîÏï° Î∞úÏÉù Í≤ÄÏ¶ù', async () => {
      // ÏûîÏï°ÏùÑ 10,000ÏõêÏúºÎ°ú ÏÑ§Ï†ï
      const existingBalance = await balanceRepository.findByUserId(1);
      if (existingBalance) {
        existingBalance.amount = 10000;
        await balanceRepository.save(existingBalance);
      } else {
        await balanceRepository.save({
          userId: 1,
          amount: 10000,
        });
      }

      const concurrentPayments = 2;
      const promises = [];

      for (let i = 0; i < concurrentPayments; i++) {
        const promise = request(app.getHttpServer())
          .post('/orders')
          .set('id', '1')
          .send({
            productOptionId: 1,
            quantity: 1,
          })
          .then((response) => response.body)
          .catch((error) => error.response?.body);
        promises.push(promise);
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.orderId);
      const failed = results.filter((result) => !result?.orderId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Í≤∞Ï†ú: ${successful.length}Í∞ú`);
      console.log(`‚ùå Ïã§Ìå®Ìïú Í≤∞Ï†ú: ${failed.length}Í∞ú`);

      // ÏµúÏ¢Ö ÏûîÏï° ÌôïÏù∏
      const finalBalance = await balanceRepository.findByUserId(1);
      console.log(`üí∞ ÏµúÏ¢Ö ÏûîÏï°: ${finalBalance.amount}Ïõê`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ ÏùåÏàò ÏûîÏï°Ïù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏùå
      expect(finalBalance.amount).toBeLessThanOrEqual(10000);
      expect(successful.length + failed.length).toBe(concurrentPayments);
    });

    it('ÏûîÏï° Î∂ÄÏ°± ÏÉÅÌô©ÏóêÏÑú Îã§Ï§ë Í≤∞Ï†ú ÏãúÎèÑ', async () => {
      const userId = 1;
      const initialBalance = await balanceRepository.findByUserId(userId);

      // ÏûîÏï°ÏùÑ 5000ÏõêÏúºÎ°ú ÏÑ§Ï†ï
      const existingBalance = await balanceRepository.findByUserId(userId);
      if (existingBalance) {
        existingBalance.amount = 5000;
        await balanceRepository.save(existingBalance);
      } else {
        await balanceRepository.save({
          userId,
          amount: 5000,
        });
      }

      const concurrentPayments = 10;
      const promises = [];

      for (let i = 0; i < concurrentPayments; i++) {
        const promise = request(app.getHttpServer())
          .post('/orders')
          .set('id', '1')
          .send({
            productOptionId: 1,
            quantity: 1,
          })
          .then((response) => response.body)
          .catch((error) => error.response?.body);
        promises.push(promise);
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.orderId);
      const failed = results.filter((result) => !result?.orderId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Í≤∞Ï†ú: ${successful.length}Í∞ú`);
      console.log(`‚ùå Ïã§Ìå®Ìïú Í≤∞Ï†ú: ${failed.length}Í∞ú`);

      // ÏµúÏ¢Ö ÏûîÏï° ÌôïÏù∏
      const finalBalance = await balanceRepository.findByUserId(userId);
      console.log(`üí∞ ÏµúÏ¢Ö ÏûîÏï°: ${finalBalance.amount}Ïõê`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ ÏùåÏàò ÏûîÏï°Ïù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏùå
      expect(finalBalance.amount).toBeLessThanOrEqual(5000);
      expect(successful.length + failed.length).toBe(concurrentPayments);
    });
  });

  describe('üé´ Ïø†Ìè∞ Î∞úÍ∏â Race Condition', () => {
    it('ÌïúÏ†ï ÏàòÎüâ Ïø†Ìè∞Ïùò Ï§ëÎ≥µ Î∞úÍ∏â Î¨∏Ï†ú', async () => {
      const maxIssuanceCount = 5;
      const concurrentIssuances = 10;
      const promises = [];

      for (let i = 0; i < concurrentIssuances; i++) {
        const promise = request(app.getHttpServer())
          .post('/coupons/1/issue')
          .set('id', '1')
          .send({})
          .then((response) => response.body)
          .catch((error) => error.response?.body);
        promises.push(promise);
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.userCouponId);
      const failed = results.filter((result) => !result?.userCouponId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Î∞úÍ∏â: ${successful.length}Í∞ú`);
      console.log(`‚ùå Ïã§Ìå®Ìïú Î∞úÍ∏â: ${failed.length}Í∞ú`);

      // Ïø†Ìè∞ Î∞úÍ∏â ÏàòÎüâ ÌôïÏù∏
      const [issuedCoupons] = await userCouponRepository.findUserCoupons(1, 1, 100);
      console.log(`üé´ Ïã§Ï†ú Î∞úÍ∏âÎêú Ïø†Ìè∞: ${issuedCoupons.length}Í∞ú`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ ÏµúÎåÄ Î∞úÍ∏â ÏàòÎüâÏùÑ Ï¥àÍ≥ºÌï† Ïàò ÏûàÏùå
      expect(issuedCoupons.length).toBeGreaterThanOrEqual(0);
      expect(successful.length + failed.length).toBe(concurrentIssuances);
    });
  });

  describe('üîÑ Î≥µÌï© ÎèôÏãúÏÑ± Î¨∏Ï†ú', () => {
    it('Ïû¨Í≥† + ÏûîÏï° + Ïø†Ìè∞Ïù¥ Î™®Îëê ÎèôÏãúÏóê Î∞úÏÉùÌïòÎäî ÌòÑÏã§Ï†Å ÏãúÎÇòÎ¶¨Ïò§', async () => {
      // ÏûîÏï°ÏùÑ 50000ÏõêÏúºÎ°ú ÏÑ§Ï†ï
      const existingBalance = await balanceRepository.findByUserId(1);
      if (existingBalance) {
        existingBalance.amount = 50000;
        await balanceRepository.save(existingBalance);
      } else {
        await balanceRepository.save({
          userId: 1,
          amount: 50000,
        });
      }

      const concurrentOrders = 20;
      const promises = [];

      for (let i = 0; i < concurrentOrders; i++) {
        const promise = request(app.getHttpServer())
          .post('/orders')
          .set('id', '1')
          .send({
            productOptionId: 1,
            quantity: 1,
            couponId: 1, // Ïø†Ìè∞ ÏÇ¨Ïö©
          })
          .then((response) => response.body)
          .catch((error) => error.response?.body);
        promises.push(promise);
      }

      const results = await Promise.all(promises);
      const successful = results.filter((result) => result?.orderId);
      const failed = results.filter((result) => !result?.orderId);

      console.log(`‚úÖ ÏÑ±Í≥µÌïú Ï£ºÎ¨∏: ${successful.length}Í∞ú`);
      console.log(`‚ùå Ïã§Ìå®Ìïú Ï£ºÎ¨∏: ${failed.length}Í∞ú`);

      // ÏµúÏ¢Ö ÏÉÅÌÉú ÌôïÏù∏
      const finalStock = await productOptionRepository.findById(1);
      const finalBalance = await balanceRepository.findByUserId(1);
      const [issuedCoupons] = await userCouponRepository.findUserCoupons(1, 1, 100);

      console.log(`üì¶ ÏµúÏ¢Ö Ïû¨Í≥†: ${finalStock.stock}Í∞ú`);
      console.log(`üí∞ ÏµúÏ¢Ö ÏûîÏï°: ${finalBalance.amount}Ïõê`);
      console.log(`üé´ Î∞úÍ∏âÎêú Ïø†Ìè∞: ${issuedCoupons.length}Í∞ú`);

      // ÎèôÏãúÏÑ± Î¨∏Ï†úÎ°ú Ïù∏Ìï¥ ÏòàÏÉÅÍ≥º Îã§Î•∏ Í≤∞Í≥ºÍ∞Ä ÎÇòÏò¨ Ïàò ÏûàÏùå
      expect(finalStock.stock).toBeLessThanOrEqual(10);
      expect(finalBalance.amount).toBeLessThanOrEqual(50000);
      expect(issuedCoupons.length).toBeGreaterThanOrEqual(0);
      expect(successful.length + failed.length).toBe(concurrentOrders);
    });
  });
});
